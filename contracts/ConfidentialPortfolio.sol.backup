// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "fhevm/lib/TFHE.sol";
import "fhevm/gateway/GatewayCaller.sol";

contract ConfidentialPortfolio is GatewayCaller {
    using TFHE for euint64;
    using TFHE for euint32;
    using TFHE for ebool;

    struct AssetRecord {
        euint64 encryptedValue;
        euint64 encryptedQuantity;
        euint32 encryptedAssetType;
        address owner;
        bool active;
        uint256 timestamp;
    }

    struct AssetType {
        uint64 minValue;
        uint64 maxValue;
        uint32 riskLevel; // in basis points (e.g., 2500 = 25%)
    }

    mapping(address => AssetRecord[]) public portfolioAssets;
    mapping(address => bool) public authorizedManagers;
    mapping(uint256 => address) public requestToInvestor;
    
    AssetType[] public supportedAssets;
    address public owner;
    uint256 public constant REQUEST_THRESHOLD = 1000000; // 1M wei minimum for asset management requests
    uint256 private requestCounter;

    event AssetAdded(address indexed investor, uint256 requestId);
    event PortfolioUpdated(address indexed investor, uint256 timestamp);
    event AuthorizedManagerAdded(address indexed manager);
    event AssetTypeUpdated(uint256 indexed index, uint64 minValue, uint64 maxValue, uint32 riskLevel);

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }

    modifier onlyAuthorized() {
        require(authorizedManagers[msg.sender] || msg.sender == owner, "Not authorized");
        _;
    }

    constructor() {
        owner = msg.sender;
        authorizedManagers[msg.sender] = true;
        
        // Initialize supported asset types (can be modified)
        supportedAssets.push(AssetType(0, 10000, 1000));      // 0-10k: Low risk 10%
        supportedAssets.push(AssetType(10001, 50000, 2200));  // 10k-50k: Medium risk 22%
        supportedAssets.push(AssetType(50001, 100000, 3500)); // 50k-100k: High risk 35%
        supportedAssets.push(AssetType(100001, type(uint64).max, 5000)); // 100k+: Very high risk 50%
    }

    function addEncryptedAsset(
        einput encryptedValue,
        einput encryptedQuantity,
        bytes calldata valueProof,
        bytes calldata quantityProof
    ) external payable returns (uint256 requestId) {
        require(msg.value >= REQUEST_THRESHOLD, "Insufficient fee for asset management");
        
        euint64 assetValue = TFHE.asEuint64(encryptedValue, valueProof);
        euint64 assetQuantity = TFHE.asEuint64(encryptedQuantity, quantityProof);
        TFHE.allowThis(assetValue);
        TFHE.allowThis(assetQuantity);
        TFHE.allow(assetValue, msg.sender);
        TFHE.allow(assetQuantity, msg.sender);

        requestId = ++requestCounter;
        requestToInvestor[requestId] = msg.sender;

        // Determine asset type based on value
        euint32 assetType = TFHE.asEuint32(0);
        euint32 riskLevel = TFHE.asEuint32(0);
        
        for (uint i = 0; i < supportedAssets.length; i++) {
            euint64 typeMin = TFHE.asEuint64(supportedAssets[i].minValue);
            euint64 typeMax = TFHE.asEuint64(supportedAssets[i].maxValue);
            euint32 typeRisk = TFHE.asEuint32(supportedAssets[i].riskLevel);
            
            // Check if asset value falls in this type range
            ebool inRange = TFHE.and(
                TFHE.ge(assetValue, typeMin),
                TFHE.le(assetValue, typeMax)
            );
            
            assetType = TFHE.select(inRange, TFHE.asEuint32(i), assetType);
            riskLevel = TFHE.select(inRange, typeRisk, riskLevel);
        }

        // Store the asset record
        AssetRecord memory newRecord = AssetRecord({
            encryptedValue: assetValue,
            encryptedQuantity: assetQuantity,
            encryptedAssetType: assetType,
            owner: msg.sender,
            active: true,
            timestamp: block.timestamp
        });

        portfolioAssets[msg.sender].push(newRecord);

        emit AssetAdded(msg.sender, requestId);
        emit PortfolioUpdated(msg.sender, block.timestamp);

        return requestId;
    }

    function getMyAssetCount() external view returns (uint256) {
        return portfolioAssets[msg.sender].length;
    }

    function getEncryptedAssetValue(uint256 recordIndex, bytes32 publicKey)
        external
        view
        returns (bytes memory)
    {
        require(recordIndex < portfolioAssets[msg.sender].length, "Asset not found");
        return TFHE.reencrypt(portfolioAssets[msg.sender][recordIndex].encryptedValue, publicKey, 0);
    }

    function getEncryptedAssetQuantity(uint256 recordIndex, bytes32 publicKey)
        external
        view
        returns (bytes memory)
    {
        require(recordIndex < portfolioAssets[msg.sender].length, "Asset not found");
        return TFHE.reencrypt(portfolioAssets[msg.sender][recordIndex].encryptedQuantity, publicKey, 0);
    }

    function getEncryptedAssetType(uint256 recordIndex, bytes32 publicKey)
        external
        view
        returns (bytes memory)
    {
        require(recordIndex < portfolioAssets[msg.sender].length, "Asset not found");
        return TFHE.reencrypt(portfolioAssets[msg.sender][recordIndex].encryptedAssetType, publicKey, 0);
    }

    function addAuthorizedManager(address manager) external onlyOwner {
        authorizedManagers[manager] = true;
        emit AuthorizedManagerAdded(manager);
    }

    function removeAuthorizedManager(address manager) external onlyOwner {
        authorizedManagers[manager] = false;
    }

    function updateAssetType(
        uint256 index,
        uint64 minValue,
        uint64 maxValue,
        uint32 riskLevel
    ) external onlyOwner {
        require(index < supportedAssets.length, "Invalid asset type index");
        require(maxValue >= minValue, "Invalid value range");
        require(riskLevel <= 10000, "Risk level cannot exceed 100%");

        supportedAssets[index] = AssetType(minValue, maxValue, riskLevel);
        emit AssetTypeUpdated(index, minValue, maxValue, riskLevel);
    }

    function addAssetType(
        uint64 minValue,
        uint64 maxValue,
        uint32 riskLevel
    ) external onlyOwner {
        require(maxValue >= minValue, "Invalid value range");
        require(riskLevel <= 10000, "Risk level cannot exceed 100%");

        supportedAssets.push(AssetType(minValue, maxValue, riskLevel));
    }

    function getAssetTypeCount() external view returns (uint256) {
        return supportedAssets.length;
    }

    function getAssetType(uint256 index) external view returns (uint64, uint64, uint32) {
        require(index < supportedAssets.length, "Invalid asset type index");
        AssetType memory assetType = supportedAssets[index];
        return (assetType.minValue, assetType.maxValue, assetType.riskLevel);
    }

    function withdrawFees() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }

    function getContractBalance() external view returns (uint256) {
        return address(this).balance;
    }

    receive() external payable {}
}